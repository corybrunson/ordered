---
output: github_document
---

<!-- README.md is generated from README.Rmd. Please edit that file -->

```{r, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>",
  fig.path = "man/figures/README-",
  out.width = "100%"
)
```

# ordered

<!-- badges: start -->
[![Lifecycle: experimental](https://img.shields.io/badge/lifecycle-experimental-orange.svg)](https://lifecycle.r-lib.org/articles/stages.html#experimental)
[![CRAN status](https://www.r-pkg.org/badges/version/ordered)](https://CRAN.R-project.org/package=ordered)
[![R-CMD-check](https://github.com/corybrunson/ordered/actions/workflows/R-CMD-check.yaml/badge.svg)](https://github.com/corybrunson/ordered/actions/workflows/R-CMD-check.yaml)
[![Codecov test coverage](https://codecov.io/gh/corybrunson/ordered/branch/main/graph/badge.svg)](https://app.codecov.io/gh/corybrunson/ordered?branch=main)
<!-- badges: end -->

`ordered` is a [parsnip](https://parsnip.tidymodels.org/) extension to enable additional classification models for ordinal outcomes (e.g., "low", "medium", "high"). While there are several model/engine combinations in the parsnip package that can be used, this package adds:

 - cumulative link (cumulative logit) ordinal regression via `MASS::polr()`
 - regularized elastic net ordinal regression models of cumulative link, adjacent categories, continuation ratio, and stopping ratio families via `ordinalNet::ordinalNet()` ([Wurm, Hanlon, and Rathouz, 2021](https://doi.org/10.18637/jss.v099.i06))
 - ordinal classification trees via `rpartScore::rpartScore()` ([Galimberti, Soffritti, and Di Maso, 2012](https://doi.org/10.18637/jss.v047.i10))
 - latent variable ordinal forests via `ordinalForest::ordfor()` ([Hornung, 2020](https://doi.org/10.1007/s00357-018-9302-x))

More will be added.

There are some existing features in tidymodels packages that are useful for ordinal outcomes: 

 - The [partykit](https://cran.r-project.org/package=partykit) engines for `parsnip::decision_tree()` and `parsnip::rand_forest()` use the ordered nature of the factors to train the model. 
 - The yardstick package has `yardstick::kap()` for weighted and unweighted Kappa statistics (the former being of more interest). Also, `yardstick::classification_cost()` can utilize more complex cost structures and uses the class probabilities for estimation. 

## Installation

You can install the development version of ordered like so:

``` r
# install.packages("pak")
pak::pak("corybrunson/ordered", dependencies = FALSE)
```

Currently, ordered relies on engine and dial registration in the following forks:

``` r
pak::pak("corybrunson/parsnip@ordered", dependencies = FALSE)
pak::pak("corybrunson/dials@ordered", dependencies = FALSE)
```

## Available models, engines, and prediction types

ordered provides new engines for several models, including all engines for `ordinal_reg()`, as summarized in the table.
Currently only predictions of `type = "class"` and `type = "prob"` are supported.

```{r, echo=FALSE, message=FALSE}
# adapted from censored:
# https://github.com/tidymodels/censored
library(ordered)
library(tibble)
library(dplyr)
library(purrr)
library(tidyr)

yep <- cli::symbol$tick
nope <- cli::symbol$cross

get_from_env("models") |> 
  enframe(name = NULL, value = "model") |> 
  mutate(dependency = map(model, get_dependency)) |> 
  unnest(dependency) |> unnest(pkg) |> 
  filter(pkg == "ordered") |> 
  mutate(info = map(model, \(.x) get_from_env(paste0(.x, "_predict")))) |> 
  nest(spec = c(model, engine, mode)) |> 
  transmute(info = map2(info, spec, inner_join, join_by(engine, mode))) |> 
  unnest(info) |> 
  select(model, engine, mode, type) |> 
  pivot_wider(
    names_from = type, values_from = mode,
    values_fill = nope, values_fn = function(x) yep
  ) |> 
  mutate(across(c(model, engine), \(.s) paste0("`", .s, "`"))) |> 
  knitr::kable()
```

## Example

Here is a simple example using computational chemistry data to predict the permeability of a molecule: 

```{r}
library(dplyr)
library(ordered)

data(caco, package = "QSARdata")

caco_dat <-
  inner_join(caco_Outcome, caco_Dragon, by = "Molecule") %>%
  as_tibble() %>%
  select(
    class = Class,
    mol_weight = QikProp_mol_MW,
    volume = QikProp_volume,
    ClogP
  )
caco_train <- caco_dat[-(1:10), ]
caco_test  <- caco_dat[ (1:10), ]

ord_rf_spec <- 
  # you should really use many more trees and score sets
  rand_forest(mtry = 2, trees = 100) %>%
  set_mode("classification") %>%
  set_engine("ordinalForest", nsets = 100)

set.seed(382)
ord_rf_fit <- ord_rf_spec %>% fit(class ~ ., data = caco_train)
augment(ord_rf_fit, new_data = caco_test)
```

## Code of Conduct

Please note that the ordered project is released with a [Contributor Code of Conduct](https://contributor-covenant.org/version/2/1/CODE_OF_CONDUCT.html). By contributing to this project, you agree to abide by its terms.

To voice support for or volunteer to contribute additional engines, please comment on [this issue](https://github.com/corybrunson/ordered/issues/15).
